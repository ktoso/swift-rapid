// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: rapid.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum JoinStatusCode: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case hostnameAlreadyInRing // = 0
  case uuidAlreadyInRing // = 1
  case sameNodeAlreadyInRing // = 2
  case safeToJoin // = 3
  case viewChangeInProgress // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .hostnameAlreadyInRing
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .hostnameAlreadyInRing
    case 1: self = .uuidAlreadyInRing
    case 2: self = .sameNodeAlreadyInRing
    case 3: self = .safeToJoin
    case 4: self = .viewChangeInProgress
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .hostnameAlreadyInRing: return 0
    case .uuidAlreadyInRing: return 1
    case .sameNodeAlreadyInRing: return 2
    case .safeToJoin: return 3
    case .viewChangeInProgress: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension JoinStatusCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [JoinStatusCode] = [
    .hostnameAlreadyInRing,
    .uuidAlreadyInRing,
    .sameNodeAlreadyInRing,
    .safeToJoin,
    .viewChangeInProgress,
  ]
}

#endif  // swift(>=4.2)

public enum EdgeStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case up // = 0
  case down // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .up
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .up
    case 1: self = .down
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .up: return 0
    case .down: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension EdgeStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [EdgeStatus] = [
    .up,
    .down,
  ]
}

#endif  // swift(>=4.2)

public enum NodeStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// this is the default value
  case ok // = 0
  case bootstrapping // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .ok
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .ok
    case 1: self = .bootstrapping
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .ok: return 0
    case .bootstrapping: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension NodeStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [NodeStatus] = [
    .ok,
    .bootstrapping,
  ]
}

#endif  // swift(>=4.2)

public struct Endpoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hostname: Data = SwiftProtobuf.Internal.emptyData

  public var port: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// All-in-one message type.
public struct RapidRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var content: RapidRequest.OneOf_Content? = nil

  public var joinMessage: JoinMessage {
    get {
      if case .joinMessage(let v)? = content {return v}
      return JoinMessage()
    }
    set {content = .joinMessage(newValue)}
  }

  public var batchedAlertMessage: BatchedAlertMessage {
    get {
      if case .batchedAlertMessage(let v)? = content {return v}
      return BatchedAlertMessage()
    }
    set {content = .batchedAlertMessage(newValue)}
  }

  public var probeMessage: ProbeMessage {
    get {
      if case .probeMessage(let v)? = content {return v}
      return ProbeMessage()
    }
    set {content = .probeMessage(newValue)}
  }

  public var fastRoundPhase2BMessage: FastRoundPhase2bMessage {
    get {
      if case .fastRoundPhase2BMessage(let v)? = content {return v}
      return FastRoundPhase2bMessage()
    }
    set {content = .fastRoundPhase2BMessage(newValue)}
  }

  public var phase1AMessage: Phase1aMessage {
    get {
      if case .phase1AMessage(let v)? = content {return v}
      return Phase1aMessage()
    }
    set {content = .phase1AMessage(newValue)}
  }

  public var phase1BMessage: Phase1bMessage {
    get {
      if case .phase1BMessage(let v)? = content {return v}
      return Phase1bMessage()
    }
    set {content = .phase1BMessage(newValue)}
  }

  public var phase2AMessage: Phase2aMessage {
    get {
      if case .phase2AMessage(let v)? = content {return v}
      return Phase2aMessage()
    }
    set {content = .phase2AMessage(newValue)}
  }

  public var phase2BMessage: Phase2bMessage {
    get {
      if case .phase2BMessage(let v)? = content {return v}
      return Phase2bMessage()
    }
    set {content = .phase2BMessage(newValue)}
  }

  public var leaveMessage: LeaveMessage {
    get {
      if case .leaveMessage(let v)? = content {return v}
      return LeaveMessage()
    }
    set {content = .leaveMessage(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Content: Equatable {
    case joinMessage(JoinMessage)
    case batchedAlertMessage(BatchedAlertMessage)
    case probeMessage(ProbeMessage)
    case fastRoundPhase2BMessage(FastRoundPhase2bMessage)
    case phase1AMessage(Phase1aMessage)
    case phase1BMessage(Phase1bMessage)
    case phase2AMessage(Phase2aMessage)
    case phase2BMessage(Phase2bMessage)
    case leaveMessage(LeaveMessage)

  #if !swift(>=4.1)
    public static func ==(lhs: RapidRequest.OneOf_Content, rhs: RapidRequest.OneOf_Content) -> Bool {
      switch (lhs, rhs) {
      case (.joinMessage(let l), .joinMessage(let r)): return l == r
      case (.batchedAlertMessage(let l), .batchedAlertMessage(let r)): return l == r
      case (.probeMessage(let l), .probeMessage(let r)): return l == r
      case (.fastRoundPhase2BMessage(let l), .fastRoundPhase2BMessage(let r)): return l == r
      case (.phase1AMessage(let l), .phase1AMessage(let r)): return l == r
      case (.phase1BMessage(let l), .phase1BMessage(let r)): return l == r
      case (.phase2AMessage(let l), .phase2AMessage(let r)): return l == r
      case (.phase2BMessage(let l), .phase2BMessage(let r)): return l == r
      case (.leaveMessage(let l), .leaveMessage(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct RapidResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var content: RapidResponse.OneOf_Content? = nil

  public var joinResponse: JoinResponse {
    get {
      if case .joinResponse(let v)? = content {return v}
      return JoinResponse()
    }
    set {content = .joinResponse(newValue)}
  }

  public var response: Response {
    get {
      if case .response(let v)? = content {return v}
      return Response()
    }
    set {content = .response(newValue)}
  }

  public var consensusResponse: ConsensusResponse {
    get {
      if case .consensusResponse(let v)? = content {return v}
      return ConsensusResponse()
    }
    set {content = .consensusResponse(newValue)}
  }

  public var probeResponse: ProbeResponse {
    get {
      if case .probeResponse(let v)? = content {return v}
      return ProbeResponse()
    }
    set {content = .probeResponse(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Content: Equatable {
    case joinResponse(JoinResponse)
    case response(Response)
    case consensusResponse(ConsensusResponse)
    case probeResponse(ProbeResponse)

  #if !swift(>=4.1)
    public static func ==(lhs: RapidResponse.OneOf_Content, rhs: RapidResponse.OneOf_Content) -> Bool {
      switch (lhs, rhs) {
      case (.joinResponse(let l), .joinResponse(let r)): return l == r
      case (.response(let l), .response(let r)): return l == r
      case (.consensusResponse(let l), .consensusResponse(let r)): return l == r
      case (.probeResponse(let l), .probeResponse(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct NodeId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var high: Int64 = 0

  public var low: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct JoinMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sender: Endpoint {
    get {return _sender ?? Endpoint()}
    set {_sender = newValue}
  }
  /// Returns true if `sender` has been explicitly set.
  public var hasSender: Bool {return self._sender != nil}
  /// Clears the value of `sender`. Subsequent reads from it will return its default value.
  public mutating func clearSender() {self._sender = nil}

  public var nodeID: NodeId {
    get {return _nodeID ?? NodeId()}
    set {_nodeID = newValue}
  }
  /// Returns true if `nodeID` has been explicitly set.
  public var hasNodeID: Bool {return self._nodeID != nil}
  /// Clears the value of `nodeID`. Subsequent reads from it will return its default value.
  public mutating func clearNodeID() {self._nodeID = nil}

  public var metadata: Metadata {
    get {return _metadata ?? Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sender: Endpoint? = nil
  fileprivate var _nodeID: NodeId? = nil
  fileprivate var _metadata: Metadata? = nil
}

public struct JoinResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sender: Endpoint {
    get {return _sender ?? Endpoint()}
    set {_sender = newValue}
  }
  /// Returns true if `sender` has been explicitly set.
  public var hasSender: Bool {return self._sender != nil}
  /// Clears the value of `sender`. Subsequent reads from it will return its default value.
  public mutating func clearSender() {self._sender = nil}

  public var statusCode: JoinStatusCode = .hostnameAlreadyInRing

  public var configurationID: UInt64 = 0

  public var endpoints: [Endpoint] = []

  public var identifiers: [NodeId] = []

  public var metadataKeys: [Endpoint] = []

  public var metadataValues: [Metadata] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sender: Endpoint? = nil
}

public struct BatchedAlertMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sender: Endpoint {
    get {return _sender ?? Endpoint()}
    set {_sender = newValue}
  }
  /// Returns true if `sender` has been explicitly set.
  public var hasSender: Bool {return self._sender != nil}
  /// Clears the value of `sender`. Subsequent reads from it will return its default value.
  public mutating func clearSender() {self._sender = nil}

  public var messages: [AlertMessage] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sender: Endpoint? = nil
}

public struct AlertMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var edgeSrc: Endpoint {
    get {return _edgeSrc ?? Endpoint()}
    set {_edgeSrc = newValue}
  }
  /// Returns true if `edgeSrc` has been explicitly set.
  public var hasEdgeSrc: Bool {return self._edgeSrc != nil}
  /// Clears the value of `edgeSrc`. Subsequent reads from it will return its default value.
  public mutating func clearEdgeSrc() {self._edgeSrc = nil}

  public var edgeDst: Endpoint {
    get {return _edgeDst ?? Endpoint()}
    set {_edgeDst = newValue}
  }
  /// Returns true if `edgeDst` has been explicitly set.
  public var hasEdgeDst: Bool {return self._edgeDst != nil}
  /// Clears the value of `edgeDst`. Subsequent reads from it will return its default value.
  public mutating func clearEdgeDst() {self._edgeDst = nil}

  public var edgeStatus: EdgeStatus = .up

  public var configurationID: UInt64 = 0

  public var ringNumber: [Int32] = []

  /// Required only for join protocol
  public var nodeID: NodeId {
    get {return _nodeID ?? NodeId()}
    set {_nodeID = newValue}
  }
  /// Returns true if `nodeID` has been explicitly set.
  public var hasNodeID: Bool {return self._nodeID != nil}
  /// Clears the value of `nodeID`. Subsequent reads from it will return its default value.
  public mutating func clearNodeID() {self._nodeID = nil}

  /// Required only for join protocol
  public var metadata: Metadata {
    get {return _metadata ?? Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _edgeSrc: Endpoint? = nil
  fileprivate var _edgeDst: Endpoint? = nil
  fileprivate var _nodeID: NodeId? = nil
  fileprivate var _metadata: Metadata? = nil
}

public struct Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FastRoundPhase2bMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sender: Endpoint {
    get {return _sender ?? Endpoint()}
    set {_sender = newValue}
  }
  /// Returns true if `sender` has been explicitly set.
  public var hasSender: Bool {return self._sender != nil}
  /// Clears the value of `sender`. Subsequent reads from it will return its default value.
  public mutating func clearSender() {self._sender = nil}

  public var configurationID: UInt64 = 0

  public var endpoints: [Endpoint] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sender: Endpoint? = nil
}

/// ******* Classic Paxos messages *********
public struct Rank {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var round: Int32 = 0

  public var nodeIndex: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Phase1aMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sender: Endpoint {
    get {return _sender ?? Endpoint()}
    set {_sender = newValue}
  }
  /// Returns true if `sender` has been explicitly set.
  public var hasSender: Bool {return self._sender != nil}
  /// Clears the value of `sender`. Subsequent reads from it will return its default value.
  public mutating func clearSender() {self._sender = nil}

  public var configurationID: UInt64 = 0

  public var rank: Rank {
    get {return _rank ?? Rank()}
    set {_rank = newValue}
  }
  /// Returns true if `rank` has been explicitly set.
  public var hasRank: Bool {return self._rank != nil}
  /// Clears the value of `rank`. Subsequent reads from it will return its default value.
  public mutating func clearRank() {self._rank = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sender: Endpoint? = nil
  fileprivate var _rank: Rank? = nil
}

public struct Phase1bMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sender: Endpoint {
    get {return _sender ?? Endpoint()}
    set {_sender = newValue}
  }
  /// Returns true if `sender` has been explicitly set.
  public var hasSender: Bool {return self._sender != nil}
  /// Clears the value of `sender`. Subsequent reads from it will return its default value.
  public mutating func clearSender() {self._sender = nil}

  public var configurationID: UInt64 = 0

  public var rnd: Rank {
    get {return _rnd ?? Rank()}
    set {_rnd = newValue}
  }
  /// Returns true if `rnd` has been explicitly set.
  public var hasRnd: Bool {return self._rnd != nil}
  /// Clears the value of `rnd`. Subsequent reads from it will return its default value.
  public mutating func clearRnd() {self._rnd = nil}

  public var vrnd: Rank {
    get {return _vrnd ?? Rank()}
    set {_vrnd = newValue}
  }
  /// Returns true if `vrnd` has been explicitly set.
  public var hasVrnd: Bool {return self._vrnd != nil}
  /// Clears the value of `vrnd`. Subsequent reads from it will return its default value.
  public mutating func clearVrnd() {self._vrnd = nil}

  public var vval: [Endpoint] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sender: Endpoint? = nil
  fileprivate var _rnd: Rank? = nil
  fileprivate var _vrnd: Rank? = nil
}

public struct Phase2aMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sender: Endpoint {
    get {return _sender ?? Endpoint()}
    set {_sender = newValue}
  }
  /// Returns true if `sender` has been explicitly set.
  public var hasSender: Bool {return self._sender != nil}
  /// Clears the value of `sender`. Subsequent reads from it will return its default value.
  public mutating func clearSender() {self._sender = nil}

  public var configurationID: UInt64 = 0

  public var rnd: Rank {
    get {return _rnd ?? Rank()}
    set {_rnd = newValue}
  }
  /// Returns true if `rnd` has been explicitly set.
  public var hasRnd: Bool {return self._rnd != nil}
  /// Clears the value of `rnd`. Subsequent reads from it will return its default value.
  public mutating func clearRnd() {self._rnd = nil}

  public var vval: [Endpoint] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sender: Endpoint? = nil
  fileprivate var _rnd: Rank? = nil
}

public struct Phase2bMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sender: Endpoint {
    get {return _sender ?? Endpoint()}
    set {_sender = newValue}
  }
  /// Returns true if `sender` has been explicitly set.
  public var hasSender: Bool {return self._sender != nil}
  /// Clears the value of `sender`. Subsequent reads from it will return its default value.
  public mutating func clearSender() {self._sender = nil}

  public var configurationID: UInt64 = 0

  public var rnd: Rank {
    get {return _rnd ?? Rank()}
    set {_rnd = newValue}
  }
  /// Returns true if `rnd` has been explicitly set.
  public var hasRnd: Bool {return self._rnd != nil}
  /// Clears the value of `rnd`. Subsequent reads from it will return its default value.
  public mutating func clearRnd() {self._rnd = nil}

  public var endpoints: [Endpoint] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sender: Endpoint? = nil
  fileprivate var _rnd: Rank? = nil
}

public struct ConsensusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ******* Node Metadata *********
public struct Metadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var metadata: Dictionary<String,Data> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct LeaveMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sender: Endpoint {
    get {return _sender ?? Endpoint()}
    set {_sender = newValue}
  }
  /// Returns true if `sender` has been explicitly set.
  public var hasSender: Bool {return self._sender != nil}
  /// Clears the value of `sender`. Subsequent reads from it will return its default value.
  public mutating func clearSender() {self._sender = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sender: Endpoint? = nil
}

public struct ProbeMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sender: Endpoint {
    get {return _sender ?? Endpoint()}
    set {_sender = newValue}
  }
  /// Returns true if `sender` has been explicitly set.
  public var hasSender: Bool {return self._sender != nil}
  /// Clears the value of `sender`. Subsequent reads from it will return its default value.
  public mutating func clearSender() {self._sender = nil}

  public var payload: [Data] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sender: Endpoint? = nil
}

public struct ProbeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: NodeStatus = .ok

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension JoinStatusCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HOSTNAME_ALREADY_IN_RING"),
    1: .same(proto: "UUID_ALREADY_IN_RING"),
    2: .same(proto: "SAME_NODE_ALREADY_IN_RING"),
    3: .same(proto: "SAFE_TO_JOIN"),
    4: .same(proto: "VIEW_CHANGE_IN_PROGRESS"),
  ]
}

extension EdgeStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UP"),
    1: .same(proto: "DOWN"),
  ]
}

extension NodeStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "BOOTSTRAPPING"),
  ]
}

extension Endpoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Endpoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hostname"),
    2: .same(proto: "port"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.hostname)
      case 2: try decoder.decodeSingularInt32Field(value: &self.port)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hostname.isEmpty {
      try visitor.visitSingularBytesField(value: self.hostname, fieldNumber: 1)
    }
    if self.port != 0 {
      try visitor.visitSingularInt32Field(value: self.port, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Endpoint, rhs: Endpoint) -> Bool {
    if lhs.hostname != rhs.hostname {return false}
    if lhs.port != rhs.port {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RapidRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RapidRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "joinMessage"),
    2: .same(proto: "batchedAlertMessage"),
    3: .same(proto: "probeMessage"),
    4: .same(proto: "fastRoundPhase2bMessage"),
    5: .same(proto: "phase1aMessage"),
    6: .same(proto: "phase1bMessage"),
    7: .same(proto: "phase2aMessage"),
    8: .same(proto: "phase2bMessage"),
    9: .same(proto: "leaveMessage"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        var v: JoinMessage?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .joinMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .joinMessage(v)}
      case 2:
        var v: BatchedAlertMessage?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .batchedAlertMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .batchedAlertMessage(v)}
      case 3:
        var v: ProbeMessage?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .probeMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .probeMessage(v)}
      case 4:
        var v: FastRoundPhase2bMessage?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .fastRoundPhase2BMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .fastRoundPhase2BMessage(v)}
      case 5:
        var v: Phase1aMessage?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .phase1AMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .phase1AMessage(v)}
      case 6:
        var v: Phase1bMessage?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .phase1BMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .phase1BMessage(v)}
      case 7:
        var v: Phase2aMessage?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .phase2AMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .phase2AMessage(v)}
      case 8:
        var v: Phase2bMessage?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .phase2BMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .phase2BMessage(v)}
      case 9:
        var v: LeaveMessage?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .leaveMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .leaveMessage(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.content {
    case .joinMessage(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    case .batchedAlertMessage(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    case .probeMessage(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    case .fastRoundPhase2BMessage(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    case .phase1AMessage(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    case .phase1BMessage(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    case .phase2AMessage(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    case .phase2BMessage(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    case .leaveMessage(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RapidRequest, rhs: RapidRequest) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RapidResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RapidResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "joinResponse"),
    2: .same(proto: "response"),
    3: .same(proto: "consensusResponse"),
    4: .same(proto: "probeResponse"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        var v: JoinResponse?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .joinResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .joinResponse(v)}
      case 2:
        var v: Response?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .response(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .response(v)}
      case 3:
        var v: ConsensusResponse?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .consensusResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .consensusResponse(v)}
      case 4:
        var v: ProbeResponse?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .probeResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .probeResponse(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.content {
    case .joinResponse(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    case .response(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    case .consensusResponse(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    case .probeResponse(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RapidResponse, rhs: RapidResponse) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NodeId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "NodeId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "high"),
    2: .same(proto: "low"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.high)
      case 2: try decoder.decodeSingularInt64Field(value: &self.low)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.high != 0 {
      try visitor.visitSingularInt64Field(value: self.high, fieldNumber: 1)
    }
    if self.low != 0 {
      try visitor.visitSingularInt64Field(value: self.low, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NodeId, rhs: NodeId) -> Bool {
    if lhs.high != rhs.high {return false}
    if lhs.low != rhs.low {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JoinMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "JoinMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "nodeId"),
    3: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._sender)
      case 2: try decoder.decodeSingularMessageField(value: &self._nodeID)
      case 3: try decoder.decodeSingularMessageField(value: &self._metadata)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._sender {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._nodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JoinMessage, rhs: JoinMessage) -> Bool {
    if lhs._sender != rhs._sender {return false}
    if lhs._nodeID != rhs._nodeID {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JoinResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "JoinResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "statusCode"),
    3: .same(proto: "configurationId"),
    4: .same(proto: "endpoints"),
    5: .same(proto: "identifiers"),
    6: .same(proto: "metadataKeys"),
    7: .same(proto: "metadataValues"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._sender)
      case 2: try decoder.decodeSingularEnumField(value: &self.statusCode)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.configurationID)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.endpoints)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.identifiers)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.metadataKeys)
      case 7: try decoder.decodeRepeatedMessageField(value: &self.metadataValues)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._sender {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.statusCode != .hostnameAlreadyInRing {
      try visitor.visitSingularEnumField(value: self.statusCode, fieldNumber: 2)
    }
    if self.configurationID != 0 {
      try visitor.visitSingularUInt64Field(value: self.configurationID, fieldNumber: 3)
    }
    if !self.endpoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.endpoints, fieldNumber: 4)
    }
    if !self.identifiers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.identifiers, fieldNumber: 5)
    }
    if !self.metadataKeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.metadataKeys, fieldNumber: 6)
    }
    if !self.metadataValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.metadataValues, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JoinResponse, rhs: JoinResponse) -> Bool {
    if lhs._sender != rhs._sender {return false}
    if lhs.statusCode != rhs.statusCode {return false}
    if lhs.configurationID != rhs.configurationID {return false}
    if lhs.endpoints != rhs.endpoints {return false}
    if lhs.identifiers != rhs.identifiers {return false}
    if lhs.metadataKeys != rhs.metadataKeys {return false}
    if lhs.metadataValues != rhs.metadataValues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BatchedAlertMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "BatchedAlertMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    3: .same(proto: "messages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._sender)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.messages)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._sender {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BatchedAlertMessage, rhs: BatchedAlertMessage) -> Bool {
    if lhs._sender != rhs._sender {return false}
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AlertMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "AlertMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "edgeSrc"),
    2: .same(proto: "edgeDst"),
    3: .same(proto: "edgeStatus"),
    4: .same(proto: "configurationId"),
    5: .same(proto: "ringNumber"),
    6: .same(proto: "nodeId"),
    7: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._edgeSrc)
      case 2: try decoder.decodeSingularMessageField(value: &self._edgeDst)
      case 3: try decoder.decodeSingularEnumField(value: &self.edgeStatus)
      case 4: try decoder.decodeSingularUInt64Field(value: &self.configurationID)
      case 5: try decoder.decodeRepeatedInt32Field(value: &self.ringNumber)
      case 6: try decoder.decodeSingularMessageField(value: &self._nodeID)
      case 7: try decoder.decodeSingularMessageField(value: &self._metadata)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._edgeSrc {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._edgeDst {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.edgeStatus != .up {
      try visitor.visitSingularEnumField(value: self.edgeStatus, fieldNumber: 3)
    }
    if self.configurationID != 0 {
      try visitor.visitSingularUInt64Field(value: self.configurationID, fieldNumber: 4)
    }
    if !self.ringNumber.isEmpty {
      try visitor.visitPackedInt32Field(value: self.ringNumber, fieldNumber: 5)
    }
    if let v = self._nodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AlertMessage, rhs: AlertMessage) -> Bool {
    if lhs._edgeSrc != rhs._edgeSrc {return false}
    if lhs._edgeDst != rhs._edgeDst {return false}
    if lhs.edgeStatus != rhs.edgeStatus {return false}
    if lhs.configurationID != rhs.configurationID {return false}
    if lhs.ringNumber != rhs.ringNumber {return false}
    if lhs._nodeID != rhs._nodeID {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Response"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Response, rhs: Response) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FastRoundPhase2bMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FastRoundPhase2bMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "configurationId"),
    3: .same(proto: "endpoints"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._sender)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.configurationID)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.endpoints)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._sender {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.configurationID != 0 {
      try visitor.visitSingularUInt64Field(value: self.configurationID, fieldNumber: 2)
    }
    if !self.endpoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.endpoints, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FastRoundPhase2bMessage, rhs: FastRoundPhase2bMessage) -> Bool {
    if lhs._sender != rhs._sender {return false}
    if lhs.configurationID != rhs.configurationID {return false}
    if lhs.endpoints != rhs.endpoints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rank: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Rank"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "round"),
    2: .same(proto: "nodeIndex"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.round)
      case 2: try decoder.decodeSingularInt32Field(value: &self.nodeIndex)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.round != 0 {
      try visitor.visitSingularInt32Field(value: self.round, fieldNumber: 1)
    }
    if self.nodeIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.nodeIndex, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rank, rhs: Rank) -> Bool {
    if lhs.round != rhs.round {return false}
    if lhs.nodeIndex != rhs.nodeIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Phase1aMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Phase1aMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "configurationId"),
    3: .same(proto: "rank"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._sender)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.configurationID)
      case 3: try decoder.decodeSingularMessageField(value: &self._rank)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._sender {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.configurationID != 0 {
      try visitor.visitSingularUInt64Field(value: self.configurationID, fieldNumber: 2)
    }
    if let v = self._rank {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Phase1aMessage, rhs: Phase1aMessage) -> Bool {
    if lhs._sender != rhs._sender {return false}
    if lhs.configurationID != rhs.configurationID {return false}
    if lhs._rank != rhs._rank {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Phase1bMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Phase1bMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "configurationId"),
    3: .same(proto: "rnd"),
    4: .same(proto: "vrnd"),
    5: .same(proto: "vval"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._sender)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.configurationID)
      case 3: try decoder.decodeSingularMessageField(value: &self._rnd)
      case 4: try decoder.decodeSingularMessageField(value: &self._vrnd)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.vval)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._sender {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.configurationID != 0 {
      try visitor.visitSingularUInt64Field(value: self.configurationID, fieldNumber: 2)
    }
    if let v = self._rnd {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._vrnd {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.vval.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.vval, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Phase1bMessage, rhs: Phase1bMessage) -> Bool {
    if lhs._sender != rhs._sender {return false}
    if lhs.configurationID != rhs.configurationID {return false}
    if lhs._rnd != rhs._rnd {return false}
    if lhs._vrnd != rhs._vrnd {return false}
    if lhs.vval != rhs.vval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Phase2aMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Phase2aMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "configurationId"),
    3: .same(proto: "rnd"),
    5: .same(proto: "vval"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._sender)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.configurationID)
      case 3: try decoder.decodeSingularMessageField(value: &self._rnd)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.vval)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._sender {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.configurationID != 0 {
      try visitor.visitSingularUInt64Field(value: self.configurationID, fieldNumber: 2)
    }
    if let v = self._rnd {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.vval.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.vval, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Phase2aMessage, rhs: Phase2aMessage) -> Bool {
    if lhs._sender != rhs._sender {return false}
    if lhs.configurationID != rhs.configurationID {return false}
    if lhs._rnd != rhs._rnd {return false}
    if lhs.vval != rhs.vval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Phase2bMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Phase2bMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "configurationId"),
    3: .same(proto: "rnd"),
    4: .same(proto: "endpoints"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._sender)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.configurationID)
      case 3: try decoder.decodeSingularMessageField(value: &self._rnd)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.endpoints)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._sender {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.configurationID != 0 {
      try visitor.visitSingularUInt64Field(value: self.configurationID, fieldNumber: 2)
    }
    if let v = self._rnd {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.endpoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.endpoints, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Phase2bMessage, rhs: Phase2bMessage) -> Bool {
    if lhs._sender != rhs._sender {return false}
    if lhs.configurationID != rhs.configurationID {return false}
    if lhs._rnd != rhs._rnd {return false}
    if lhs.endpoints != rhs.endpoints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ConsensusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ConsensusResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ConsensusResponse, rhs: ConsensusResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Metadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBytes>.self, value: &self.metadata)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.metadata.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBytes>.self, value: self.metadata, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metadata, rhs: Metadata) -> Bool {
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LeaveMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "LeaveMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._sender)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._sender {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LeaveMessage, rhs: LeaveMessage) -> Bool {
    if lhs._sender != rhs._sender {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProbeMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ProbeMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    3: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._sender)
      case 3: try decoder.decodeRepeatedBytesField(value: &self.payload)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._sender {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.payload.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.payload, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProbeMessage, rhs: ProbeMessage) -> Bool {
    if lhs._sender != rhs._sender {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProbeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ProbeResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.status)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .ok {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProbeResponse, rhs: ProbeResponse) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
